#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

// Функция для добавления двух строк с числами
string addStrings(const string& num1, const string& num2) {
    string result = ""; // Результат сложения
    int dischargeCarry = 0; // Разряд переноса
    int FirstCurrentIndex = num1.length() - 1; // Индекс текущей цифры в num1
    int secondCurrentIndex = num2.length() - 1; // Индекс текущей цифры в num2

    // Складываем цифры чисел, пока не достигнем конца одного из чисел
    while (FirstCurrentIndex >= 0 || secondCurrentIndex >= 0) {
        int digit1 = (FirstCurrentIndex >= 0) ? num1[FirstCurrentIndex] - '0' : 0; // Текущая цифра num1
        int digit2 = (secondCurrentIndex >= 0) ? num2[secondCurrentIndex] - '0' : 0; // Текущая цифра num2

        // Вычисляем сумму цифр и разряд переноса
        int sum = digit1 + digit2 + dischargeCarry;
        dischargeCarry = sum / 10;
        sum %= 10;

        // Добавляем текущую цифру суммы в результат
        result.insert(0, 1, sum + '0');

        // Уменьшаем индексы
        FirstCurrentIndex--;
        secondCurrentIndex--;
    }

    // Если остался разряд переноса, добавляем его в результат
    if (dischargeCarry > 0) {
        result.insert(0, 1, dischargeCarry + '0');
    }

    return result;
}

// Функция для вычитания двух строк с числами
string subtractLongNumbers(const string& num1, const string& num2) {
    vector<int> result; // Результат вычитания
    vector<int> arr1(num1.length()); // Цифры первого числа
    vector<int> arr2(num2.length()); // Цифры второго числа

    // Заполняем массивы цифрами чисел (обратный порядок)
    for (int posOfDigit = 0; posOfDigit < num1.length(); ++posOfDigit) {
        arr1[posOfDigit] = num1[num1.length() - 1 - posOfDigit] - '0';
    }
    for (int posOfDigit = 0; posOfDigit < num2.length(); ++posOfDigit) {
        arr2[posOfDigit] = num2[num2.length() - 1 - posOfDigit] - '0';
    }

    int borrow = 0; // Разряд заема

    // Выполняем вычитание цифр чисел
    for (int curDigit = 0; curDigit < arr1.size(); ++curDigit) {
        int diff = arr1[curDigit] - borrow;
        if (curDigit < arr2.size()) {
            diff -= arr2[curDigit];
        }
        if (diff < 0) {
            diff += 10;
            borrow = 1;
        } else {
            borrow = 0;
        }
        result.push_back(diff);
    }

    // Удаляем ведущие нули в результате
    while (result.size() > 1 && result.back() == 0) {
        result.pop_back();
    }

    // Преобразуем результат обратно в строку
    string resultString = "";
    for (int posOfDigit = result.size() - 1; posOfDigit >= 0; --posOfDigit) {
        resultString += to_string(result[posOfDigit]);
    }

    return resultString;
}

// Функция для умножения двух строк с числами
string multiplyStrings(const string& num1, const string& num2) {
    string result = "0"; // Результат умножения

    // Умножаем каждую цифру num1 на num2 и добавляем результаты
    // с учетом позиции цифры в исходном числе
    for (int posOfDigit = num1.length() - 1; posOfDigit >= 0; --posOfDigit) {
        string tempResult = ""; // Результат умножения текущей цифры num1 на num2
        int carry = 0; // Разряд переноса

        // Умножаем текущую цифру num1 на num2
        int digit1 = num1[posOfDigit] - '0';
        for (int tempDigit = num2.length() - 1; tempDigit >= 0; --tempDigit) {
            int digit2 = num2[tempDigit] - '0';

            int product = digit1 * digit2 + carry;
            carry = product / 10;
            product %= 10;

            tempResult.insert(0, 1, product + '0');
        }

        // Если остался разряд переноса, добавляем его в результат
        if (carry > 0) {
            tempResult.insert(0, 1, carry + '0');
        }

        // Добавляем нули в конец в зависимости от позиции цифры
        for (int nullPos = posOfDigit; nullPos < num1.length() - 1; ++nullPos) {
            tempResult.append("0");
        }

        // Складываем результат текущего умножения с общим результатом
        result = addStrings(result, tempResult);
    }

    return result;
}

// Функция для целочисленного деления двух строк с числами
string divideStrings(const string& num1, const string& num2) {
    string result = ""; // Частное от деления
    string dividend = num1; // Делимое

    // Если делимое меньше делителя, возвращаем 0
    if (dividend.length() < num2.length() ||
        (dividend.length() == num2.length() && dividend < num2)) {
        return "0";
    }

    // Производим деление пока делимое не станет меньше делителя
    while (dividend.length() >= num2.length()) {
        string quotient = ""; // Частное текущего деления
        string tempDividend = dividend.substr(0, num2.length()); // Подстрока делимого длины делителя

        // Вычитаем делитель из подстроки делимого
        while (tempDividend.length() > 0) {
            string tempQuotient = "0"; // Частное текущего вычитания
            string tempSubtract = "";

            // Увеличиваем частное текущего вычитания на единицу
            while (tempSubtract.length() < tempDividend.length() && tempSubtract <= tempDividend) {
                tempSubtract = addStrings(tempSubtract, num2);
                tempQuotient = addStrings(tempQuotient, "1");
            }

            // Уменьшаем подстроку делимого на указанное число вычитаний
            tempDividend = subtractLongNumbers(tempDividend, tempSubtract);

            // Удаляем ведущие нули
            while (tempDividend.length() > 1 && tempDividend[0] == '0') {
                tempDividend.erase(0, 1);
            }

            // Добавляем частное текущего вычитания в общее частное
            quotient.append(tempQuotient);
        }

        // Добавляем ведущие нули в частное в зависимости от позиции
        // подстроки делимого в исходном числе
        for (int leading zero = 0; leading zero < dividend.length() - tempDividend.length(); ++leading zero) {
            quotient.insert(0, 1, '0');
        }

        // Добавляем текущее частное к общему частному
        result = addStrings(result, quotient);

        // Удаляем подстроку делимого из делимого
        dividend = dividend.substr(tempDividend.length(), dividend.length() - tempDividend.length());
    }

    return result;
}

// Функция для сравнения двух строк с числами
int compareStrings(const string& num1, const string& num2) {
    // Если длины чисел разные, меньшее число имеет меньшую длину
    if (num1.length() < num2.length()) {
        return -1;
    } else if (num1.length() > num2.length()) {
        return 1;
    }

    // Длины чисел равны, сравниваем цифры по порядку
    for (int posForСomparison = 0; posForСomparison < num1.length(); ++posForСomparison) {
        if (num1[posForСomparison] < num2[posForСomparison]) {
            return -1;
        } else if (num1[posForСomparison] > num2[posForСomparison]) {
            return 1;
        }
    }

    // Числа равны
    return 0;
}

int main() {
    string num1, num2;
    cout << "Введите первое число: ";
    cin >> num1;
    cout << "Введите второе число: ";
    cin >> num2;

    // Сложение
    string sum = addStrings(num1, num2);
    cout << "Сумма: " << sum << endl;

    // Вычитание
    string difference = subtractLongNumbers(num1, num2);
    cout << "Разность: " << difference << endl;

    // Умножение
    string product = multiplyStrings(num1, num2);
    cout << "Произведение: " << product << endl;

    // Целочисленное деление
    string quotient = divideStrings(num1, num2);
    cout << "Частное: " << quotient << endl;

    // Сравнение
    int comparison = compareStrings(num1, num2);
    if (comparison < 0) {
        cout << "Первое число меньше второго" << endl;
    } else if (comparison > 0) {
        cout << "Первое число больше второго" << endl;
    } else {
        cout << "Числа равны" << endl;
    }

    return 0;
}


    return 0;
}
